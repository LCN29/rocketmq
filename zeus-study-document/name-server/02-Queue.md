
## 


## Topic 、Queue、 CommitLog、ConsumeQueue 和 IndexFile 的关系

```log
/var/rocketmq/store
├── commitlog                   # 存储所有消息内容
│   ├── 00000000000000000000
│   ├── 00000000001073741824
│   └── ...
├── config                      # 存储配置文件
│   ├── consumerOffset.json     # 存储消费者的消费进度
│   ├── delayOffset.json        # 存储延迟消息进度
│   ├── subscriptionGroup.json  # 存储订阅组信息
│   └── topics.json             # 存储主题配置信息
├── consumequeue                # 存储每个主题的消息队列索引
│   ├── TopicA
│   │   ├── 0
│   │   │   ├── 00000000000000000000
│   │   │   ├── 00000000000000000001
│   │   │   └── ...
│   │   ├── 1
│   │       ├── 00000000000000000000
│   │       ├── 00000000000000000001
│   │       └── ...
│   └── TopicB
│       ├── 0
│       │   ├── 00000000000000000000
│       │   ├── 00000000000000000001
│       │   └── ...
│       ├── 1
│           ├── 00000000000000000000
│           ├── 00000000000000000001
│           └── ...
├── index                       # 存储消息索引文件
│   ├── 20210602101245678
│   ├── 20210602112356789
│   └── ...
└── checkpoint                  # 存储刷盘进度
    ├── checkpoint
```

一个 Topic 可以有多个 Queue，每个 Queue 对应一个 ConsumeQueue 文件，ConsumeQueue 文件中存储了消息在 CommitLog 文件中的物理偏移量，以及消息的长度和 Tag 的 HashCode, 每个 ConsumeQueue 文件的记录大小是固定的（20 字节）
所有 Topic 和 Queue 的消息数据都存储在同一个 CommitLog 文件中, CommitLog 文件默认大小为 1GB，文件写满后会创建新的文件进行存储。
IndexFile 是基于消息的 key 创建的索引文件。如果消息带有 key，会在 IndexFile 中记录消息的索引。IndexFile 文件的命名规则是时间戳，每个 IndexFile 文件中存储了多个消息的索引信息。




## Light Message Queue 的核心作用 Lmq

1. 支持超大规模队列：
传统 RocketMQ 中，一个 Topic 的每个队列（Queue）对应 Broker 上的具体存储文件（ConsumeQueue 和 CommitLog 的索引），这种架构在队列数量增多时会导致存储和元数据的压力陡增。
Light Queue 模式通过简化存储设计，可以支持数百万甚至更多的队列而不会带来显著性能损耗。

2. 资源利用率优化：
传统模式中，每个 Queue 都需要预留一定的存储资源，即使队列很少使用也会占用磁盘和内存。
Light Queue 通过共享 CommitLog 等机制，显著降低存储开销，使得资源使用更加高效。

3. 提升吞吐量：
为了适应高并发的生产者和消费者场景，Light Queue 的设计能够减少 IO 操作并降低队列的存储和检索复杂度，从而提升吞吐量。

4. 简化运维：
通过动态队列扩展和轻量化管理，运维复杂度大大降低。
对于频繁扩容缩容的场景，Light Queue 的灵活性更强，适应动态变化的业务需求。

实际应用场景: 超大规模 Topic

1. 场景：大规模用户消息推送，可能需要数百万个队列，每个用户对应一个队列。
作用：Light Queue 减少元数据和存储压力，同时提供高效的消息传递。
多租户隔离：

2. 场景：一个 RocketMQ 集群服务于多个业务部门，每个部门需要独立的队列。
作用：通过 Light Queue 实现高密度的队列部署，同时避免资源浪费。
高并发场景：

3. 场景：实时日志分析、IoT 数据采集等需要处理高吞吐量的业务。
作用：Light Queue 提高了队列的并发能力，优化了系统的吞吐。